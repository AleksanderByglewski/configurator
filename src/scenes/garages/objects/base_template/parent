   // let position_x = this.state.get('position_x') || 0
        // let position_y = this.state.get('position_y') || 0
        // let position_z = this.state.get('position_z') || 0

        const passive_accessers=[
            // new accesser('name', 'Menu do debugowania obiektu'),
        ]

        const dynamic_accessers = [
            new accesser('name', 'Menu do debugowania obiektu'),
            new accesser('position_x'),
            new accesser('position_y'),
            new accesser('position_z'),
        ]

        const accessers=[ ...passive_accessers,...dynamic_accessers]

        let self=this
        function update_accesser_values(accessers){
            accessers.forEach(element=>{
                element.value=self.state.get(element)

            })

        }

        update_accesser_values(dynamic_accessers) 
        this.set_mediator(this)
        this.set_the_options(this, accessers)

        // const { accessersWallFront, accessersWallBack, accessersWallLeft, accessersWallRight } = this.determineState();
        //      let array = [
        //          { objectOptions: accessersWallFront, classInstance: WallGarageController },
        //          { objectOptions: accessersWallBack, classInstance: WallGarageController },
        //          { objectOptions: accessersWallLeft, classInstance: WallGarageController },
        //          { objectOptions: accessersWallRight, classInstance: WallGarageController }
        //  ]

        // let array = [
        // { objectOptions: accessersWallFront, classInstance:WallController},
        // // { objectOptions: accessersWallBack, classInstance: WallController },
        // // { objectOptions: accessersWallLeft, classInstance: WallController },
        // { objectOptions: accessersWallRight, classInstance: WallController }
        // ]


        //This is probably the moment when we should clean the group
        // function disposeNode(node){
        //     if (node instanceof THREE.Mesh) {
        //         if (node.geometry) {
        //             node.geometry.dispose();
        //         }
        
        //         if (node.material) {
                   
        //                 if (node.material.map) node.material.map.dispose();
        //                 if (node.material.lightMap) node.material.lightMap.dispose();
        //                 if (node.material.bumpMap) node.material.bumpMap.dispose();
        //                 if (node.material.normalMap) node.material.normalMap.dispose();
        //                 if (node.material.specularMap) node.material.specularMap.dispose();
        //                 if (node.material.envMap) node.material.envMap.dispose();
        
        //                 node.material.dispose();   // disposes any programs associated with the material
                    
        //         }
        //     } 
        // }
        
        // // Remove and dispose all children
        // while(this.group.children.length > 0){ 
        //     let child = this.group.children[0];
        //     this.group.remove(child); 
        //     disposeNode(child);
        // }

        let self_array=[]
        self_array=this.generatePassiveObjects()

        let external_array=this.external_objects
        

        for (let i=0;i<external_array.length; i++){
            this.group.add(external_array[i])
        }
        // const array=[ ...self_array, ...external_array]
        const array=[ ...self_array]
        

        // let array = [
        // { objectOptions: accessersWallFront, classInstance:WallController},
        // // { objectOptions: accessersWallBack, classInstance: WallController },
        // // { objectOptions: accessersWallLeft, classInstance: WallController },
        // { objectOptions: accessersWallRight, classInstance: WallController }
        // ]
        // // array=[]

        // this.children.forEach((child) => {
        //     child.handleEvent('recursivelyRemoveModel')
        // });
        // this.children = []

        // array.forEach(({ objectOptions, classInstance }) => {
        //     this.display.set_scene(this.display.get_scene())
        //     const created_object = this.object_addition.bind(this)(objectOptions, classInstance);
        //     // console.log(created_object)
        //     this.group.add(created_object)
        //     // console.log(t)
        // });
        let outer_scene=this.display.get_scene()
        
        array.forEach(({ objectOptions, classInstance }) => {

                this.display.set_scene(this.display.get_scene())
                const added_object = new classInstance()
                added_object.display.set_scene(outer_scene)
                added_object.set_the_options(added_object, objectOptions)
                added_object.model.create(added_object.state.state)
                this.addChild(added_object)
                added_object.handleEvent('buildingStep')
                this.group.add(added_object.model.get_model())   
                this.group.add(added_object.group)
        })


        for (let i=0;i<this.external_objects_controllers.length; i++){
            // this.group.add(this.external_objects[i])
       
            for (let j=0;j<this.group.children.length; j++){
                this.external_objects_controllers[i].group.add(this.group.children[j])
            }
        }

        // const axesHelper = new THREE.AxesHelper(5); // Set the size based on your needs
        // this.group.add(axesHelper);

        let hasControllers = false;
        let currentMediator = this.mediator;

        while (currentMediator) {
       
            if (currentMediator.external_objects_controllers.length > 0) {
                hasControllers = true;
                break;
            }
            if(currentMediator==currentMediator.mediator){
                break;
            }

            currentMediator = currentMediator.mediator;
          

        }
        
        if(!hasControllers){
        this.display.get_scene().add(this.group)
        }


        // if(this.external_objects_controllers.length==0){
        // this.display.get_scene().add(this.group)
        // }
        this.basicTransformation()
        //console.log(this.state.state)
        
    }